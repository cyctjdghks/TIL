# Pessimistic Locking (비관적 잠금)와 Optimistic Locking (낙관적 잠금)

여러 트랜잭션이 동시에 실행될 때 데이터베이스의 일관성과 무결성을 유지하기 위해 동시성 제어 메커니즘이 필요합니다. 두 가지 주요 동시성 제어 전략, "Optimistic Locking"과 "Pessimistic Locking"은 이러한 목적을 달성하기 위해 사용됩니다.

동시성 제어 없이 여러 트랜잭션이 동시에 동일한 데이터에 액세스하면 다음과 같은 문제가 발생할 수 있습니다:

1. **Dirty Reads**: 하나의 트랜잭션에서 변경한 데이터를 다른 트랜잭션이 읽게 되면서 아직 커밋되지 않은 데이터를 읽게 될 수 있습니다.
2. **Non-repeatable Reads**: 하나의 트랜잭션 내에서 동일한 데이터를 여러 번 읽을 때마다 다른 결과가 반환될 수 있습니다.
3. **Phantom Reads**: 하나의 트랜잭션 내에서 한 번의 쿼리와 다음 쿼리 사이에 새로운 레코드가 삽입되거나 삭제될 수 있습니다.
4. **Lost Updates**: 두 개 이상의 트랜잭션이 동일한 레코드를 거의 동시에 업데이트할 경우, 하나의 트랜잭션에 의한 업데이트가 다른 트랜잭션에 의해 덮어쓰여질 수 있습니다.

### 1. Pessimistic Locking (비관적 잠금)

- **개념**: 비관적 잠금은 이름에서 알 수 있듯이 동시성 문제가 발생할 것이라고 "비관적"으로 생각하고, 데이터에 접근하기 전에 미리 잠금을 거는 방식입니다.
	- 트랜잭션의 충돌이 발생한다고 가정합니다.
	- 하나의 트랜잭션이 자원에 접근시 락을 걸고, 다른 트랜잭션이 접근하지 못하게 합니다.
	- 데이터베이스에서 Shared Lock(공유, 읽기 잠금) 이나 Exclusive Lock(배타, 쓰기 잠금) 을 겁니다.
	- Shared Lock 의 경우, 다른 트랜잭션에서 읽기만 가능합니다. 또한 Exclusive lock 적용이 불가능합니다. (읽는동안 변경하는것을 막기 위해)
	- Exclusive lock 의 경우. 다른 트랜잭션에서 읽기, 쓰기가 둘다 불가능합니다. 또한 Shared, Exclusive Lock 적용이 추가적으로 불가능합니다. (쓰는동안 읽거나, 다른 쓰기가 오는것을 막기위해)
- **동작 방식**: 
  - 특정 데이터 레코드를 사용자 A가 수정하려고 할 때, 해당 레코드를 잠가 다른 사용자 B는 해당 레코드를 수정하거나 접근할 수 없게 됩니다.
  - 사용자 A가 작업을 완료하고 잠금을 해제하면, 다른 사용자 B는 그 후에 해당 레코드에 접근할 수 있습니다.
- **장점**: 
  - 데이터의 일관성 유지가 쉽습니다.
  - 동시성 문제에 대한 명확한 해결 방법 제공.
  - 충돌이 자주 발생하는 환경에 대해서는 롤백의 횟수를 줄일 수 있으므로 성능에서 유리합니다.
  - 데이터 무결성을 보장하는 수준이 매우 높습니다.
- **단점**: 
  - 데이터 자체에 락을 걸어버리므로 동시성이 떨어져 성능 손해를 많이 보게 됩니다. 특히 읽기가 많이 이루어지는 데이터베이스의 경우에는 손해가 더 두드러집니다.
  - 잠금으로 인해 대기 시간이 발생할 수 있어 성능 이슈가 생길 수 있습니다.
  - 교착상태(Deadlock)가 발생할 위험이 있습니다.

### 2. Optimistic Locking (낙관적 잠금)

- **개념**: 낙관적 잠금은 동시성 문제가 발생할 가능성이 낮다고 "낙관적"으로 가정하고, 처음부터 잠금을 걸지 않습니다. 대신, 실제 변경을 커밋하려는 시점에 충돌 여부를 확인하는 방식입니다.
	- 트랜잭션의 충돌이 발생하지 않을것이라고 기대합니다.
	- 일단 충돌이 나는것을 막지 않고, 충돌이 난것을 감지하면 그때 처리합니다.
	- 일반적으로 version 의 상태를 보고 충돌을 확인하며, 충돌이 확인된경우 롤백을 진행시킵니다. (hashcode나 timestamp를 이용해서 충돌을 확인할 수 도 있습니다.)
	- DB단에서 동시성을 처리하는것이 아닌, 어플리케이션단에서 처리 합니다.
	- 여러 작업이 묶인 트랜잭션으로 요청이 간 경우가 실패한경우, 개발자가 직접 롤백 처리 를 해주어야합니다.
- **동작 방식**: 
  - 버전 번호나 타임스탬프와 같은 것을 사용하여 데이터의 변경을 감지합니다.
  - 사용자 A와 사용자 B가 동일한 레코드를 동시에 수정하려고 할 때, 먼저 커밋하는 사용자의 수정이 반영됩니다.
  - 나중에 커밋하려는 사용자는 이미 변경된 데이터를 기반으로 수정했기 때문에 충돌이 감지되고, 해당 사용자는 다시 작업을 수행하거나 다른 조치를 취해야 합니다.
- **장점**: 
  - 대부분의 시스템에서 동시에 동일한 데이터를 수정하는 경우가 드물기 때문에, 낙관적 잠금이 더 효율적일 수 있습니다.
  - 충돌이 안난다는 가정하에, 동시 요청에 대해서 처리 성능이 좋습니다.
  - 교착상태의 위험이 적습니다.
- **단점**: 
  - 데이터 충돌이 발생하면 재작업이 필요하게 됩니다.
  - 잦은 충돌이 일어나는경우 롤백처리에 대한 비용이 많이 들어 오히려 성능에서 손해를 볼 수 있습니다.
  - 롤백 처리를 구현하는게 복잡할 수 있습니다.

## Conclusion

- **비관적 락** 은 데이터의 무결성이 중요하고, 충돌이 많이 발생하여 잦은 롤백으로 인한 효율성 문제가 발생하는것이 예상되는 시나리오에서좋습니다.
- **낙관적 락** 은 실제로 데이터 충돌이 자주 일어나지 않을것이라고 예상되는 시나리오에서 좋습니다.
- 데이터베이스 설계 단계에서 충돌여부가 발생하는지 어느정도 추측은 가능하나 확실치 않으므로, **애매한경우 비관적락** 을 걸어두고 서비스 도중 실제로 **충돌이 자주 일어나지 않는것이 확인** 된 경우에 **낙관적락** 을 사용하는것이 좋지 않을까 생각합니다.