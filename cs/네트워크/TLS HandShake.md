# TLS/SSL HandShake

<br>

```
HTTPS에서 클라이언트와 서버간 통신 전
SSL 인증서로 신뢰성 여부를 판단하기 위해 연결하는 방식
```

<br>

![image](https://user-images.githubusercontent.com/34904741/139517776-f2cac636-5ce5-4815-981d-33905283bf13.png)

<br>

### 진행 순서

1. 클라이언트는 서버에게 `client hello` 메시지를 담아 서버로 보낸다.
   이때 암호화된 정보를 함께 담는데, `버전`, `암호 알고리즘`, `압축 방식` 등을 담는다.

   <br>

2. 서버는 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받고, `세션 ID`와 `CA 공개 인증서`를 `server hello` 메시지와 함께 담아 응답한다. 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다.

   <br>

3. 클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 진행한다.

   <br>

4. CA 인증서에 대한 신뢰성이 확보되었다면, 클라이언트는 난수 바이트를 생성하여 서버의 공개키로 암호화한다. 이 난수 바이트는 대칭키를 정하는데 사용이 되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.

   <br>

5. 만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면, 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.

   <br>

6. 서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.

   <br>

7. 클라이언트는 handshake 과정이 완료되었다는 `finished` 메시지를 서버에 보내면서, 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다.

   <br>

8. 서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로  `finished` 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.

   <br>

9. 클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고, 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고받을 수 있게 된다.

```

1. 클라이언트 헬로(Client Hello): 클라이언트는 서버에게 이 단계를 시작합니다. 이 메시지에는 클라이언트가 지원하는 SSL/TLS 버전, 암호화 스위트 목록(클라이언트가 지원하는 암호화 알고리즘들), 그리고 랜덤으로 생성된 데이터가 포함됩니다.
2. 서버 헬로(Server Hello): 서버는 클라이언트 헬로 메시지를 받고, 서버가 지원하는 SSL/TLS 버전, 선택된 암호화 스위트, 그리고 서버가 생성한 랜덤 데이터를 클라이언트에게 전송합니다.
3. 인증 및 키 교환 : 서버는 자신의 인증서를 클라이언트에게 전송합니다. 이 인증서에는 공개키가 포함되어 있습니다. 이를 이용해 클라이언트는 서버의 신원을 확인하게 됩니다. 클라이언트가 서버를 신뢰할 경우, 클라이언트는 자신의 랜덤 데이터와 서버의 랜덤 데이터, 그리고 세션에 사용될 'Pre-Master Secret'을 생성하고 이를 서버의 공개키로 암호화하여 서버에게 전송합니다.
4. 세션 키 생성 : 클라이언트와 서버 모두 이제 'Pre-Master Secret'와 랜덤 데이터를 사용하여 동일한 'Master Secret'을 생성합니다. 그 다음에 이 'Master Secret'는 세션 동안 사용될 'Session Key'를 생성하는 데 사용됩니다. 이 'Session Key'는 실제 데이터를 암호화하고 복호화하는 데 사용되는 대칭키입니다.
5. 핸드셰이크 종료 : 이제 클라이언트와 서버는 암호화된 데이터를 주고받을 준비가 되었습니다. 클라이언트와 서버 모두 "Change Cipher Spec" 메시지를 보내고, 이후로는 'Session Key'를 사용하여 모든 메시지를 암호화합니다. 마지막으로, "Finished" 메시지가 교환되며 이 메시지는 이전에 교환된 모든 메시지의 무결성을 확인하는 데 사용됩니다.
```
이렇게 TLS/SSL 핸드셰이크에서는 공개키 암호화 방식이 서버의 신원을 인증하고, 안전하게 대칭키를 교환하는데 사용됩니다. 이후의 세션에서는 대칭키 암호화 방식이 실제 데이터의 암호화 및 복호화에 사용됩니다. 대칭키 암호화는 공개키 암호화 방식에 비해 계산이 덜 복잡하기 때문에, 대량의 데이터를 빠르게 처리하는데 적합합니다. 따라서, 이 두 가지 암호화 방식을 혼합해서 사용하면 보안성과 효율성을 동시에 달성할 수 있습니다.

#### 요약
1. 클라이언트 헬로를 통해 서버에 요청을 보내고
2. 서버가 인증서를 클라이언트에게 전달합니다. 인증서에는 서버의 공개키가 포함되어 있습니다.
3. 클라이언트는 서버의 공개키를 이용하여 "Pre-Master Secret"이라는 임시 키를 생성하고, 이를 암호화하여 서버에게 전달합니다.
4. 서버는 자신의 개인키를 사용하여 암호화된 "Pre-Master Secret"을 복호화합니다. 이제 클라이언트와 서버 모두 "Pre-Master Secret"을 갖게 됩니다.
=>  서버가 보내준 공개키로 클라이언트가 공개키를 이용해 대칭키를 생성하고 그걸 공개키로 암호화해서 서버로 보내는고 서버는 그걸 복호화해서 해당 대칭키를 사용
