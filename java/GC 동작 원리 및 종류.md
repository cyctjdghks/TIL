# GC(Garbage Collector)의 종류와 동작 과정, 원리

## 가비지 컬렉터(Garbage Collector)란?
가비지 컬렉터는 힙 메모리 관리를 위해 참조되고 있지 않은 객체들을 메모리에서 삭제하는 역할을 합니다.

## 객체의 제거 조건
객체는 힙 영역에 저장되고, 스택 영역에 이를 가리키는 주소값이 저장됩니다. 힙 영역에서 자신을 가리키는 주소값이 없으면 해당 객체는 참조되고 있지 않다고 판단합니다.

## GC 동작 과정
1. 객체 생성: 객체가 생성되면 메모리를 young 영역에 저장합니다.
2. Young 영역 관리:
   - 최초 생성된 객체는 Eden 영역에 위치합니다.
   - Eden 영역에서 Minor GC가 발생하면 참조 중인 객체만을 남기고, 나머지 객체들은 제거됩니다.
   - Eden 영역에서 살아남은 객체들은 1번 Survivor 영역으로 이동하며, 나이(Age)가 1 증가합니다.
   - 1번 Survivor 영역에서 살아남은 객체들은 2번 Survivor 영역으로 이동하며, 다시 나이가 1 증가합니다.

3. Survivor에서 Old로의 이동:
   - 1번 Survivor 영역에 위치한 객체들은 나이가 증가하며, 특정 나이 값(Age Threshold)에 도달하면 Old 영역으로 이동합니다.
   - Age Threshold는 일반적으로 JVM에 내장된 값으로, 주로 15 또는 16입니다.

4. Old 영역 관리:
   - Old 영역에 있는 객체들은 Major GC가 발생했을 때 참조 여부에 따라 유지되거나 제거됩니다.

![image](../img/GC%20구조.png)

## GC 알고리즘 종류
1. **Serial GC**:
   - 단순한 방식의 GC로 싱글 스레드로 동작하며 처리가 느립니다.
   - Mark-sweep-compact 알고리즘을 사용합니다.
   - 메모리와 CPU 코어 갯수가 적을 때 적합합니다.

2. **Parallel GC**:
   - Java 8의 default GC로, Serial GC와 알고리즘은 같지만 GC를 처리하는 Thread가 여러 개입니다.
   - 메모리와 코어가 충분할 때 적합합니다.

3. **Parallel Old GC**:
   - Parallel GC와 유사하지만 Old 영역까지 멀티스레드를 사용합니다.
   - Old 영역에서의 GC 알고리즘을 개선한 버전입니다.

## GC의 장단점
### 장점:
- 메모리 누수를 방지합니다.
- 해제된 메모리에 접근하는 오류와 이중 해제를 방지합니다.

### 단점:
- GC의 메모리 해제 타이밍을 개발자가 정확하게 알기 어렵습니다.
- 실시간성이 강조되는 프로그램에서는 GC에게 메모리를 맡기는 것이 적절하지 않을 수 있습니다.

## STW(Stop-The-World)
Old 영역이 가득차면 major GC 또는 Full GC가 동작하는데 이때 STW 상태가 되므로 이를 최소화 하는 것이 중요하다.

STW(Stop-The-World)은 GC 처리하는 동안 Java의 프로세스가 모두 멈춰버리는 현상이다.

## Permanent 영역 (Java 7 이전)

Permanent 영역은 Java 7 이전 버전에서 사용되던 메모리 영역으로, 주로 클래스 메타데이터와 관련된 정보를 저장합니다. 그러나 Permanent 영역은 크기가 고정되어 있어서 메모리 관리에 어려움을 초래하고, 메모리 누수와 관련된 문제를 일으킬 수 있습니다.

클래스 로딩, 메서드 정보, 상수 풀(Constant Pool), 스트링 풀 등과 같은 JVM 내부 정보가 Permanent 영역에 저장됩니다. 일반적으로 다음과 같은 문제점이 있습니다:
- 크기 조절이 어려워 메모리 문제를 유발할 수 있음.
- 메모리 누수 문제 발생 가능.
- 일부 애플리케이션에서 PermGen 영역 부족으로 인한 OutOfMemoryError 발생 가능.

## Native Memory(Metaspace)

Native Memory는 Java 8 이후 버전에서 Permanent 영역 대신 사용되는 메모리 영역입니다. 이 영역은 클래스 메타데이터와 관련된 정보를 저장하는데 사용됩니다. Native Memory는 Permanent 영역의 문제를 해결하고 JVM 메모리 관리를 개선하는 데 도움을 줍니다.

Native Memory의 특징 및 장점은 다음과 같습니다:

- 크기가 동적으로 조절 가능하여 메모리 관리가 용이합니다.
- 클래스 로딩 및 언로딩에 따른 메모리 누수 문제가 해결됩니다.
- JVM이 필요한 만큼의 메모리를 동적으로 할당하므로 OutOfMemoryError가 줄어듭니다.
- 클래스 로딩 및 메타데이터 관리가 더 효율적으로 이루어집니다.

Java 8부터는 Native Memory를 통해 클래스 메타데이터를 관리하므로, Permanent 영역과 관련된 문제를 걱정할 필요가 없습니다. 이로써 메모리 관리와 안정성이 개선되며, 자바 애플리케이션의 성능과 안정성이 향상됩니다.
